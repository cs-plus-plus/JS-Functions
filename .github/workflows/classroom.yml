name: Classroom Autograder – Unit 8.6 (Functions)

on:
  - push
  - pull_request
  - workflow_dispatch

permissions:
  checks: write
  actions: read
  contents: read
 
jobs:
  autograde:
    runs-on: ubuntu-latest
    if: github.actor != 'github-classroom[bot]'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install test dependencies
        run: |
          npm init -y >/dev/null 2>&1 || true
          npm install --save-dev jest@29 jsdom@21 jest-environment-jsdom@29

      - name: Jest setup
        run: |
          cat > jest.setup.cjs <<'EOF'
          const { TextEncoder, TextDecoder } = require('util');
          if (typeof global.TextEncoder === 'undefined') global.TextEncoder = TextEncoder;
          if (typeof global.TextDecoder === 'undefined') global.TextDecoder = TextDecoder;
          EOF

      - name: Jest config
        run: |
          cat > jest.config.cjs <<'EOF'
          module.exports = {
            testEnvironment: 'jsdom',
            setupFiles: ['<rootDir>/jest.setup.cjs'],
            testMatch: ['**/__tests__/**/*.test.cjs']
          };
          EOF

      - name: Write tests
        run: |
          mkdir -p __tests__
          cat > __tests__/functions-8_6.test.cjs <<'EOF'
          const fs = require('fs');
          const path = require('path');
          const { JSDOM, VirtualConsole } = require('jsdom');

          const wait = (ms=50) => new Promise(r => setTimeout(r, ms));
          const find = arr => arr.find(p => fs.existsSync(p)) || null;
          const findIndex = () => find(['index.html','public/index.html','src/index.html','docs/index.html']);

          function text(doc, id) {
            const el = doc.getElementById(id);
            return (el?.textContent || el?.innerText || '').trim();
          }

          function setVal(doc, id, v) {
            const el = doc.getElementById(id);
            if (!el) return false;
            el.value = String(v);
            return true;
          }

          async function loadDOM() {
            const idx = findIndex();
            if (!idx) throw new Error('index.html not found.');

            const vconsole = new VirtualConsole();
            vconsole.on('error', () => {}); // silence console errors in CI

            const baseDir = path.dirname(path.resolve(idx));
            const baseUrl = 'file://' + baseDir.replace(/\\+/g, '/') + '/';

            const dom = await JSDOM.fromFile(idx, {
              url: baseUrl,
              runScripts: 'dangerously',
              resources: 'usable',
              pretendToBeVisual: true,
              virtualConsole: vconsole
            });

            dom.window.prompt = () => { throw new Error('Use inputs, not prompt().'); };
            dom.window.alert  = () => { throw new Error('Use textContent, not alert().'); };

            await new Promise(res => dom.window.addEventListener('load', res, { once: true }));
            await wait();
            return dom;
          }

          describe('Unit 8.6 – Functions (Buttons + textContent)', () => {
            let dom, window, document;
            let originalLog;

            beforeAll(async () => {
              dom = await loadDOM();
              window = dom.window;
              document = window.document;
              originalLog = console.log;
            });

            beforeEach(() => { console.log = jest.fn(); });
            afterEach(() => { console.log = originalLog; });

            test('required elements exist (5 buttons, inputs, outputs)', () => {
              const btnIds = ['btnMyFunc','btnRandom','btnAdder','btnDistance','btnQuadratic'];
              const outIds = ['outMyFunc','outRandom','outAdder','outDistance','outQuadratic'];
              const inIds  = ['maxRand','addX','addY','x1','y1','x2','y2','qa','qb','qc'];
              btnIds.forEach(id => expect(document.getElementById(id)).not.toBeNull());
              outIds.forEach(id => expect(document.getElementById(id)).not.toBeNull());
              inIds.forEach(id  => expect(document.getElementById(id)).not.toBeNull());
            });

            test('myFunc: counter increments and writes via textContent (no console.log)', async () => {
              const btn = document.getElementById('btnMyFunc');
              const out = () => text(document,'outMyFunc');
              btn.click(); await wait();
              const first = out();
              btn.click(); await wait();
              const second = out();
              const n1 = parseInt(first.match(/-?\d+/)?.[0] || '0', 10);
              const n2 = parseInt(second.match(/-?\d+/)?.[0] || '0', 10);
              expect(n2).toBeGreaterThan(n1);
              expect(console.log).not.toHaveBeenCalled();
            });

            test('getRandomNum(max): result 1..max or 0 when invalid (written to #outRandom)', async () => {
              setVal(document,'maxRand','12');
              document.getElementById('btnRandom').click(); await wait();
              const r1 = parseInt(text(document,'outRandom').match(/-?\d+/)?.[0] || '0', 10);
              expect(r1).toBeGreaterThanOrEqual(1);
              expect(r1).toBeLessThanOrEqual(12);
              setVal(document,'maxRand','0');
              document.getElementById('btnRandom').click(); await wait();
              const r0 = parseInt(text(document,'outRandom').match(/-?\d+/)?.[0] || '9999', 10);
              expect(r0).toBe(0);
              expect(console.log).not.toHaveBeenCalled();
            });

            test('myAdder(x,y): sum shown in #outAdder (no console.log)', async () => {
              setVal(document,'addX','2'); setVal(document,'addY','3');
              document.getElementById('btnAdder').click(); await wait();
              const sum = parseFloat(text(document,'outAdder').match(/-?\d+(\.\d+)?/)?.[0] || 'NaN');
              expect(sum).toBeCloseTo(5, 6);
              expect(console.log).not.toHaveBeenCalled();
            });

            test('distance(x1,y1,x2,y2): numeric distance shown in #outDistance (≈4.2426; no console.log)', async () => {
              setVal(document,'x1','4'); setVal(document,'y1','5');
              setVal(document,'x2','7'); setVal(document,'y2','2');
              document.getElementById('btnDistance').click(); await wait();
              const d = parseFloat(text(document,'outDistance').match(/-?\d+(\.\d+)?/)?.[0] || 'NaN');
              expect(d).toBeCloseTo(Math.sqrt(18), 2);
              expect(console.log).not.toHaveBeenCalled();
            });

            test('quadratic(a,b,c): roots shown in #outQuadratic (handle double root)', async () => {
              setVal(document,'qa','1'); setVal(document,'qb','2'); setVal(document,'qc','1');
              document.getElementById('btnQuadratic').click(); await wait();
              const t = text(document,'outQuadratic');
              const nums = (t.match(/-?\d+(\.\d+)?/g) || []).map(Number);
              expect(nums.some(n => Math.abs(n - (-1)) < 1e-3)).toBe(true);
              expect(console.log).not.toHaveBeenCalled();
            });
            // --- EXTRA QUADRATIC TESTS (real distinct roots + complex roots) ---

            // Case 1: two real, distinct roots (Δ > 0)
            // Example: a=1, b=-3, c=2  → roots 1 and 2 (order may vary)
            test('quadratic(a,b,c): two real distinct roots (Δ>0) show both roots', async () => {
              setVal(document, 'qa', '1');
              setVal(document, 'qb', '-3');
              setVal(document, 'qc', '2');
              document.getElementById('btnQuadratic').click(); 
              await wait();

              const t = text(document, 'outQuadratic');
              const nums = (t.match(/-?\d+(\.\d+)?/g) || []).map(Number);

              // We just need to see 1 and 2 somewhere in the output (any order).
              const has1 = nums.some(n => Math.abs(n - 1) < 1e-3);
              const has2 = nums.some(n => Math.abs(n - 2) < 1e-3);

              expect(has1 && has2).toBe(true);
              expect(console.log).not.toHaveBeenCalled();
            });

            // Case 2: complex conjugate roots (Δ < 0)
            // Example: a=1, b=1, c=1 → -0.5 ± 0.866025... i
            // We accept any clear complex formatting, e.g. "-0.5 ± 0.866i", "-0.5 + 0.866i, -0.5 - 0.866i", etc.
            test('quadratic(a,b,c): complex roots (Δ<0) show real and imaginary parts (with "i")', async () => {
              setVal(document, 'qa', '1');
              setVal(document, 'qb', '1');
              setVal(document, 'qc', '1');
              document.getElementById('btnQuadratic').click(); 
              await wait();

              const t = text(document, 'outQuadratic');

              // Must include an "i" to indicate complex form
              expect(/i\b/i.test(t)).toBe(true);

              // Extract numbers present; expect approximately -0.5 and 0.866...
              const nums = (t.match(/-?\d+(\.\d+)?/g) || []).map(Number);
              const hasReal = nums.some(n => Math.abs(n - (-0.5)) < 1e-2);
              const hasImag = nums.some(n => Math.abs(n - 0.866) < 2e-2); // tolerant

              expect(hasReal).toBe(true);
              expect(hasImag).toBe(true);
              expect(console.log).not.toHaveBeenCalled();
            });

          });
          EOF

      - name: Write helper (shared map + check runner)
        run: |
          cat > run_one.cjs <<'NODE'
          const fs = require('fs');
          const { spawnSync } = require('child_process');

          const CHECKS = {
            REQUIRED:  { label:'required elements exist',
                         re:/^required elements exist \(5 buttons, inputs, outputs\)$/ },
            MYFUNC:    { label:'myFunc increments & writes',
                         re:/^myFunc: counter increments and writes via textContent \(no console\.log\)$/ },
            RANDOM:    { label:'getRandomNum in range',
                         re:/^getRandomNum\(max\): result 1\.\.max or 0 when invalid \(written to #outRandom\)$/ },
            ADDER:     { label:'myAdder shows sum',
                         re:/^myAdder\(x,y\): sum shown in #outAdder \(no console\.log\)$/ },
            DISTANCE:  { label:'distance shows numeric value',
                         re:/^distance\(x1,y1,x2,y2\): numeric distance shown in #outDistance .*no console\.log\)$/ },
            QUADRATIC: { label:'quadratic shows roots',
                         re:/^quadratic\(a,b,c\): roots shown in #outQuadratic \(handle double root\)$/ },
          };

          const key = process.argv[2];
          if (!key || !CHECKS[key]) {
            console.error('Usage: node run_one.cjs <KEY>');
            process.exit(2);
          }

          if (!fs.existsSync('jest-summary.json')) {
            spawnSync('npx', ['jest','--runInBand','--json','--outputFile=jest-summary.json'], { stdio:'inherit' });
          }

          let jr = {};
          try { jr = JSON.parse(fs.readFileSync('jest-summary.json','utf8')); } catch {}
          const assertions = (jr.testResults||[]).flatMap(t => t.assertionResults || []);
          const a = assertions.find(x => CHECKS[key].re.test(x.title));

          if (a && a.status === 'passed') {
            console.log(`✅ ${CHECKS[key].label}`);
            process.exit(0);
          } else {
            console.log(`❌ ${CHECKS[key].label}`);
            process.exit(1);
          }
          NODE

      - name: Run full Jest suite once
        run: npx jest --runInBand --json --outputFile=jest-summary.json || true

      # ---------- GRADING ----------
      - name: required elements exist
        id: t_required
        uses: classroom-resources/autograding-command-grader@v1
        with:
          test-name: required elements exist
          setup-command: echo "ready"
          command: node run_one.cjs REQUIRED
          timeout: 60
          max-score: 10

      - name: myFunc increments & writes
        id: t_myfunc
        uses: classroom-resources/autograding-command-grader@v1
        with:
          test-name: myFunc increments & writes
          setup-command: echo "ready"
          command: node run_one.cjs MYFUNC
          timeout: 60
          max-score: 20

      - name: getRandomNum in range
        id: t_random
        uses: classroom-resources/autograding-command-grader@v1
        with:
          test-name: getRandomNum in range
          setup-command: echo "ready"
          command: node run_one.cjs RANDOM
          timeout: 60
          max-score: 20

      - name: myAdder shows sum
        id: t_adder
        uses: classroom-resources/autograding-command-grader@v1
        with:
          test-name: myAdder shows sum
          setup-command: echo "ready"
          command: node run_one.cjs ADDER
          timeout: 60
          max-score: 20

      - name: distance shows numeric value
        id: t_distance
        uses: classroom-resources/autograding-command-grader@v1
        with:
          test-name: distance shows numeric value
          setup-command: echo "ready"
          command: node run_one.cjs DISTANCE
          timeout: 60
          max-score: 15

      - name: quadratic shows roots
        id: t_quadratic
        uses: classroom-resources/autograding-command-grader@v1
        with:
          test-name: quadratic shows roots
          setup-command: echo "ready"
          command: node run_one.cjs QUADRATIC
          timeout: 60
          max-score: 15

      # ---------- SUMMARY ----------
      - name: Build summary
        run: |
          node - <<'NODE'
          const fs = require('fs');
          const checks = {
            REQUIRED:/^required elements exist \(5 buttons, inputs, outputs\)$/,
            MYFUNC:/^myFunc: counter increments and writes via textContent \(no console\.log\)$/,
            RANDOM:/^getRandomNum\(max\): result 1\.\.max or 0 when invalid \(written to #outRandom\)$/,
            ADDER:/^myAdder\(x,y\): sum shown in #outAdder \(no console\.log\)$/,
            DISTANCE:/^distance\(x1,y1,x2,y2\): numeric distance shown in #outDistance .*no console\.log\)$/,
            QUADRATIC:/^quadratic\(a,b,c\): roots shown in #outQuadratic \(handle double root\)$/,
          };
          let jr = {};
          try { jr = JSON.parse(fs.readFileSync('jest-summary.json','utf8')); } catch {}
          const assertions = (jr.testResults||[]).flatMap(t => t.assertionResults || []);
          const status = {};
          for (const [k,re] of Object.entries(checks)) {
            const a = assertions.find(x => re.test(x.title));
            status[k] = !!a && a.status === 'passed';
          }
          const passed = Object.values(status).filter(Boolean).length;
          const total = Object.keys(status).length;
          const lines = [];
          lines.push('# Unit 8.6 Autograder Summary','');
          lines.push(`Passed: ${passed}/${total}`,'');
          for (const [k] of Object.entries(checks))
            lines.push(`${status[k] ? '✅' : '❌'} ${k.toLowerCase().replace(/_/g,' ')}`);
          lines.push('','## Checks');
          for (const a of assertions)
            lines.push(`- ${a.status==='passed'?'✅':'❌'} ${a.title}`);
          fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, lines.join('\n'));
          NODE

      - name: Autograding Reporter
        uses: classroom-resources/autograding-grading-reporter@v1
        env:
          T_REQUIRED_RESULTS:  ${{ steps.t_required.outputs.result }}
          T_MYFUNC_RESULTS:    ${{ steps.t_myfunc.outputs.result }}
          T_RANDOM_RESULTS:    ${{ steps.t_random.outputs.result }}
          T_ADDER_RESULTS:     ${{ steps.t_adder.outputs.result }}
          T_DISTANCE_RESULTS:  ${{ steps.t_distance.outputs.result }}
          T_QUADRATIC_RESULTS: ${{ steps.t_quadratic.outputs.result }}
        with:
          runners: t_required,t_myfunc,t_random,t_adder,t_distance,t_quadratic
